const asyncHandler = require('express-async-handler');
const TrendingAlert  = require('../models/TrendingAlert');
const  Alert  = require('../models/Alert');
const Zone  = require('../models/Zone');
const Route = require('../models/Route');
const turf = require('@turf/turf'); // For geospatial analysis
const mongoose = require('mongoose');

// Function to validate coordinates, also a prototype of a middleware that can be used if the API grows
// This function checks if the coordinates are valid and within Morocco's bounds
function validateCoordinates(coord) {
    if (
      Array.isArray(coord) &&
      coord.length === 2 &&
      typeof coord[0] === 'number' &&
      typeof coord[1] === 'number' &&
      coord[0] >= -180 && coord[0] <= 180 && // Longitude
      coord[1] >= -90 && coord[1] <= 90     // Latitude
      // This is done to avoid non existent coordinates
    ) {
      return true;
    }
    return false;
  }
  
// @desc    Generate optimal route between points
// @route   POST /api/routes/generate
// @access  Private (Admin only)
// Function to generate a route between two points while avoiding hazards and alerts
// This function is called when an admin wants to create a route for evacuation, supply, or emergency access
const generateRoute = asyncHandler(async (req, res) => {
  const { start, end, routeType } = req.body;
  if (!start || !end || !routeType) {
    return res.status(400).json({ 
      success: false, 
      message: 'Missing required fields' 
    });
  }

  // We first validate input coordinates
  if (!validateCoordinates(start) || !validateCoordinates(end)) {
    return res.status(400).json({ 
      success: false, 
      message: 'Invalid start/end coordinates' 
    });
  }

  // We then fetch danger zones and active alerts
  // This is done to later calculate the optimal path
  // We use Promise.all to fetch both collections in parallel
  const [dangerZones, activeAlerts] = await Promise.all([
    Zone.find({ 
      type: { $in: ['hazard', 'restricted'] },
      geometry: {
        $geoIntersects: {
          $geometry: {
            type: 'LineString',
            coordinates: [start, end] // Preliminary straight line
          }
        }
      }
    }),
    // We only fetch active alerts that are not expired
    // We use $gt operator to filter alerts that are still valid
    Alert.find({ 
      expiresAt: { $gt: new Date() } 
    }).select('location type severity')
  ]);

  // We generate the route using the helper function
    // This function will calculate the optimal path while avoiding the danger zones and active alerts
    // The function is defined below
  const routePath = await calculateOptimalPath(
    start, 
    end, 
    dangerZones, 
    activeAlerts
  );

  // Here we save the generated route to the database
  const newRoute = await Route.create({
    name: `${routeType} Route ${new Date().toLocaleString()}`,
    type: routeType,
    geometry: {
      type: 'LineString',
      coordinates: routePath
    },
    startPoint: { coordinates: start },
    endPoint: { coordinates: end },
    distance: turf.length(turf.lineString(routePath), { units: 'kilometers' }),
    safetyScore: calculateSafetyScore(routePath, dangerZones, activeAlerts),
    avoids: {
      zones: dangerZones.map(z => z._id),
      alerts: activeAlerts.map(a => a._id)
    },
    // Tagging the route with the admin who created it
    createdBy: req.admin._id
  });

  res.status(201).json({
    success: true,
    data: newRoute,
    message: 'Safe route generated successfully'
  });
  console.log(`Route generated by admin ${req.admin._id} at ${new Date().toISOString()}`);
});

// We calculate the optimal path by avoiding hazards and alerts
// This function uses Turf.js to calculate the shortest path while avoiding obstacles
async function calculateOptimalPath(start, end, zones, alerts) {
    // First we validate all input parameters to ensure they meet requirements
    // This prevents errors downstream and provides clear feedback
  
    // Wealidate start and end coordinates
    // We use the existing validateCoordinates function but add additional checks
    if (!validateCoordinates(start) || !validateCoordinates(end)) {
      throw new Error('Invalid start or end coordinates');
    }
  
    // We validate zones array exists and each zone has valid geometry
    // This ensures we don't process malformed zone data
    if (!Array.isArray(zones)) {
      throw new Error('Zones must be provided as an array');
    }
    zones.forEach(zone => {
      if (!zone?.geometry?.coordinates || !Array.isArray(zone.geometry.coordinates)) {
        throw new Error(`Invalid zone geometry: ${JSON.stringify(zone)}`);
      }
    });
  
    // We validate alerts array exists and each alert has valid location
    // Similar to zones but with alert-specific checks
    if (!Array.isArray(alerts)) {
      throw new Error('Alerts must be provided as an array');
    }
    alerts.forEach(alert => {
      if (!alert?.location?.coordinates || !Array.isArray(alert.location.coordinates)) {
        throw new Error(`Invalid alert location: ${JSON.stringify(alert)}`);
      }
      if (!['high', 'medium', 'low'].includes(alert.severity)) {
        throw new Error(`Invalid alert severity: ${alert.severity}`);
      }
    });
  
    // We create GeoJSON Feature objects for all areas to avoid
    // Each feature includes a buffer distance based on its type and severity
    const avoidanceAreas = [
      // Process hazard zones with 500m buffer
      // We convert each zone to a proper GeoJSON Feature
      ...zones.map(zone => {
        // This is a debug log to inspect zone geometry
        // console.log(`Processing zone: ${zone._id} with geometry:`, zone.geometry);
        return {
          type: 'Feature',
          geometry: zone.geometry,
          properties: { 
            buffer: 500, // 500m buffer for all zones
            type: 'zone', // For debugging
            zoneId: zone._id // For reference
          }
        };
      }),
      
      // Process alerts with severity-based buffers
      // High severity gets 800m buffer, others get 300m
      ...alerts.map(alert => {
        // Debug log to inspect alert location (commented out in production)
        // console.log(`Processing alert: ${alert._id} with location:`, alert.location);
        
        return {
          type: 'Feature',
          geometry: alert.location,
          properties: {
            buffer: alert.severity === 'high' ? 800 : 300,
            type: 'alert', // This is for debugging
            alertId: alert._id, // For reference
            severity: alert.severity // For debugging
          }
        };
      })
    ];
  
    // We double-check that all avoidance areas are valid GeoJSON features
    // This catches any formatting issues before they reach Turf.js
  
    avoidanceAreas.forEach((area, index) => {
      if (!area.type || area.type !== 'Feature') {
        throw new Error(`Avoidance area at index ${index} missing Feature type`);
      }
      if (!area.geometry || !area.geometry.coordinates) {
        throw new Error(`Avoidance area at index ${index} has invalid geometry`);
      }
      if (typeof area.properties?.buffer !== 'number') {
        throw new Error(`Avoidance area at index ${index} has invalid buffer`);
      }
    });

    // With validated inputs, we now calculate the optimal path
    // We include comprehensive error handling for the Turf.js operation
  
    const options = {
      obstacles: avoidanceAreas,
      resolution: 100, // meters between path points
      minDistance: 1000 // minimum path length (meters)
    };
  
    try {
      // Debug log to show inputs to Turf.js 
      // console.log('Calculating path with options:', {
      //   start,
      //   end,
      //   obstacleCount: avoidanceAreas.length,
      //   options
      // });
  
      const path = turf.shortestPath(
        turf.point(start),
        turf.point(end),
        options
      );
  
      // We validate the resulting path
      if (!path?.geometry?.coordinates || path.geometry.coordinates.length < 2) {
        console.error('Invalid path generated:', path);
        throw new Error('Path calculation failed - generated invalid path');
      }
  
      // Another debug log to show successful path 
      // console.log('Successfully generated path with', 
      //   path.geometry.coordinates.length, 'points');
  
      return path.geometry.coordinates;
  
    } catch (error) {
      console.error('Path calculation error:', {
        error: error.message,
        start,
        end,
        zoneCount: zones.length,
        alertCount: alerts.length
      });
      
      // This is a fallback to straight line if the path calculation fails
      console.warn('Using straight-line path as fallback');
      return [start, end];
    }
  }

// Here we calculate the safety score of the generated route
function calculateSafetyScore(path, zones, alerts) {
  const pathLine = turf.lineString(path);
  // Initializing the danger score to 0
  // This score will be incremented based on the proximity of zones and alerts to the path
  let dangerScore = 0;

  // We check zone's proximity to the path
    // We use Turf.js to calculate the distance from the path to each zone
  zones.forEach(zone => {
    const distance = turf.pointToLineDistance(
      turf.centroid(turf.polygon(zone.geometry.coordinates)),
      pathLine,
      { units: 'kilometers' }
    );
    // We add to the danger score based on the distance from the path
    // The closer the zone, the higher the danger score
    dangerScore += Math.max(0, 100 - (distance * 1000)); // Convert km to meters
  });

  // We check alert's proximity to the path
    // We use the same method as above to calculate the distance from the path to each alert
  alerts.forEach(alert => {
    const distance = turf.pointToLineDistance(
      turf.point(alert.location.coordinates),
      pathLine,
      { units: 'kilometers' }
    );
    const severityMultiplier = alert.severity === 'high' ? 1.5 : 1;
    dangerScore += Math.max(0, 150 - (distance * 1000)) * severityMultiplier;
  });

  return Math.max(0, 100 - Math.min(dangerScore / 10, 100));
}

// @desc    Get all routes with pagination and filtering
// @route   GET /api/routes
// @access  Public
// This function fetches all routes with optional pagination and filtering
const getAllRoutes = asyncHandler(async (req, res) => {
    try {
      // As usual we extract query parameters with defaults and create a filter object
      const { type, page = 1, limit = 10, sort = '-createdAt' } = req.query;

      const filter = {};
      if (type) {
        filter.type = { $regex: type, $options: 'i' };
      }
        const skip = (page - 1) * limit;
  
      // We execute a pagination & filtering query
      // We use mongoose's find method to filter and sort the routes
      const routes = await Route.find(filter)
        .sort(sort)
        .skip(skip)
        .limit(Number(limit))
        .populate('createdBy', 'username email')
        .populate('avoids.zones', 'name type')
        .populate('avoids.alerts', 'type severity');


      // We count the total number of documents matching the filter
      // This is used for pagination
      const total = await Route.countDocuments(filter);
  
      res.status(200).json({
        success: true,
        count: routes.length,
        total,
        page: Number(page),
        totalPages: Math.ceil(total / limit),
        data: routes
      });
    } catch (error) {
      console.error('Error fetching routes:', error);
      res.status(500).json({
        success: false,
        message: 'Server error while fetching routes',
        error: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }
  });
  
  // @desc    Get specific route by ID
  // @route   GET /api/routes/:id
  // @access  Public
  // This function fetches a single route by its ID with detailed information
  const getRouteById = asyncHandler(async (req, res) => {
    try {
      // We validate the ID format before querying the database
      if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
        return res.status(400).json({ 
          success: false, 
          message: 'Invalid route ID format' 
        });
      }
  
      // We find route with populated data
      const route = await Route.findById(req.params.id)
        .populate('createdBy', 'username email')
        .populate('avoids.zones', 'name type geometry')
        .populate('avoids.alerts', 'type severity location');
  
      if (!route) {
        // If the route doesn't exist we return a 404 error
        return res.status(404).json({ 
          success: false, 
          message: 'Route not found' 
        });
      }
  
      // We recalculat the safety score based on the current geometry and active alerts
      // This is done to ensure the score is up-to-date
      const [dangerZones, activeAlerts] = await Promise.all([
        Zone.find({ _id: { $in: route.avoids.zones } }),
        Alert.find({ 
          _id: { $in: route.avoids.alerts },
          expiresAt: { $gt: new Date() }
        })
      ]);

      // We use the calculateSafetyScore function to get the current score
      // This function is defined above and uses Turf.js for geospatial analysis
      const updatedRoute = route.toObject();
      updatedRoute.currentSafetyScore = calculateSafetyScore(
        route.geometry.coordinates,
        dangerZones,
        activeAlerts
      );
  

        // We return the route with the updated safety score and a success message
      res.status(200).json({ 
        success: true, 
        data: updatedRoute 
      });
    } catch (error) {
      console.error('Error fetching route:', error);
      res.status(500).json({
        success: false,
        message: 'Server error while fetching route',
        error: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }
  });
  
  // @desc    Update a route
  // @route   PUT /api/routes/:id
  // @access  Private (Admin only)
  // This function allows updating route metadata (not the path itself)
  const updateRoute = asyncHandler(async (req, res) => {
    try {
      // ID format validation
      if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
        return res.status(400).json({ 
          success: false, 
          message: 'Invalid route ID format' 
        });
      }
  
      // We prevent geometry modification through this endpoint
      if (req.body.geometry || req.body.startPoint || req.body.endPoint) {
        return res.status(400).json({
          success: false,
          message: 'Use /generate to modify route path'
        });
      }
  
      // We extract the update fields from the request body
      // We use the spread operator to only include fields that are present in the request body
      const { name, description, type } = req.body;
      const updateData = { 
        ...(name && { name }),
        ...(description && { description }),
        ...(type && { type }),
        updatedAt: Date.now(),
        updatedBy: req.admin._id
      };
  
      // We find the route by ID and update it with the new data
      const updatedRoute = await Route.findByIdAndUpdate(
        req.params.id,
        updateData,
        { 
          new: true,
          runValidators: true 
        }
      ).populate('createdBy', 'username email');

      // If the route doesn't exist we return a 404 error
  
      if (!updatedRoute) {
        return res.status(404).json({ 
          success: false, 
          message: 'Route not found' 
        });
      }
  
      // Otherwise we return the updated route with a success message
      res.status(200).json({
        success: true,
        message: `Route "${updatedRoute.name}" updated successfully`,
        data: updatedRoute
      });
    } catch (error) {
      console.error('Error updating route:', error);
      res.status(500).json({
        success: false,
        message: 'Server error while updating route',
        error: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }
  });
  
  // @desc    Delete a route
  // @route   DELETE /api/routes/:id
  // @access  Private (Admin only)
  // This function permanently deletes a route from the system
  const deleteRoute = asyncHandler(async (req, res) => {
    try {
      // We validate the ID format
      if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
        return res.status(400).json({ 
          success: false, 
          message: 'Invalid route ID format' 
        });
      }
  
      // We get the route's details for logging purposes
      const route = await Route.findById(req.params.id);
      if (!route) {
        return res.status(404).json({ 
          success: false, 
          message: 'Route not found' 
        });
      }
  
      // We perform the deletion
      await Route.findByIdAndDelete(req.params.id);
  
      res.status(200).json({
        success: true,
        message: `Route "${route.name}" deleted successfully`,
        deletedId: req.params.id
      });
      // We log the deletion for auditing purposes
        // This is useful for tracking admin actions in the system
      console.log(`Route ${req.params.id} deleted by admin ${req.admin._id} at ${new Date().toISOString()}`);
    } catch (error) {
      console.error('Error deleting route:', error);
      res.status(500).json({
        success: false,
        message: 'Server error while deleting route',
        error: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }
  });
  
  module.exports = {
    generateRoute,
    getAllRoutes,
    getRouteById,
    updateRoute,
    deleteRoute
  };